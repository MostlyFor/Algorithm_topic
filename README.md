# leetcode-daily-challenge




day 1. xor 연산에 대해서 공부할 수 있는 문제 (교환법칙, 결합법칙 성립) \
day 2. bit 연산에 대해서 공부할 수 있는 문제, 정보 저장할 때 bit 활용하면 꽤 유용함. 
  shift 연산자보다 산술 연산자가 우선순위가 더 높음.

day 4. 시간 복잡도에 대해서 생각해 볼 수 있는 문제. 그리고 set의 탐색, 삽입의 시간 복잡도 (nlog n)을 생각해볼 수 있는 문제.
  가끔 코드를 짜다보면 log 1 + log 2 + ... + log N가 나오는데 nlogn - n < logn! < (n+1)log(n+1) - n 에서 O (nlog n)이 된다. <참고 : Stirling's approximation>
  

day 7. 2차원 부분합 

day 8. NQUEEN 문제로 처음엔 일단 비효율적으로 풀었다. 이때 2차원 배열을 인수로 받기 위해서 c++에서 2차원 배열이 메모리 상에 어떻게 배치 되는지 생각해 볼 수 있었다



day 12. 이 문제를 풀기 이전에 Two Sum 1 문제를 풀었다. 그 문제에선 다음을 얻을 수 있었다. \
검색 문제에서 데이터가 작은 경우에는 시간복잡도를 줄이기 위해 hash를 사용하자. map과는 달리 정렬하지 않아서 시간복잡도가 상수이다.

다시 이 문제로 돌아와서 이 문제는 상수 공간복잡도를 사용하는 대신 새로운 조건인 non decreasing order 이 생겼다. 이를 잘 생각해보면 O(N)으로 해결할 수 있다.
