1. 최댓값과 최솟값
공백을 기점으로 문자열을 쪼개서 받는 문제
substr을 사용할 때 substr(시작위치, 개수)에서 개수를 상수보단 인덱스를 활용해야 실수 적음!

3. 최솟값 만들기
모든 경우의 수를 계산하기 위해선 1000!이 필요하다. 그래서 다른 직관적인 방법을 생각해내는 것을 요구하는 풀이였고 결국 최솟값을 만들기 위해서는 오름차순[i] * 내림차순[i]를 해야한다.
이건 귀류법을 사용하면 간단하게 증명이 가능하다.
처음에 오름차순[i] * 내림차순[i] 가 최소값이 아니다 라고 가정하고 출발하여 임의의 한 쌍의 곱을 바꾸어보면 증명 가능하다.

5. 이진 변환 반복하기
이진수를 구하는 방법으로 bitset과 비트 연산과 그냥 구현이 있는다.

6. 숫자의 표현
같은 연산의 중복이 프로그래밍의 핵심이다. 이 문제에서도 계산의 중복을 최소화하려고 생각하다보니 투 포인터 알고리즘이 생각났다. 1에서 시작하는 경우 2에서 시작하는 경우로 쭉 생각하다보니 중복이 보였다.

