10. 영어 끝말잇기
나는 set을 써서 했지만 정렬 시간이 필요한 set보다는 unordered set을 쓰는게 더 좋은 풀이다. (set에 들어가는 문자열의 수가 적어서 충돌은 일어나지 않는다.)
- 참고로 set은 이진 트리 형태로 구현되어 삽입, 삭제, 원소접근 모두 O(lg N)!


11. 구명보트
전형적인 그리디 문제, 증명도 까다로운 편이 아니다.
그리디 + 투 포인터


14. 점프와 순간 이동
처음에 증명할 수 있는 풀이를 생각하지 못하고 시험장인 것처럼 증명 안하고 풀었다. 운 좋게 통과는 되었다.
증명 된 풀이는 2배씩 이동하는 것에서 비트 연산을 생각하는 것이었다.
2배 간다면 1001 칸에서 10010 가는 것이므로 왼쪽으로 한 칸 이동시키는 것이다. 즉, 이진수로 표현했을 때 1의 개수만큼 비용이 소모된다.

2배 가는 것에서 비트 연산을 생각할 수 있도록 해보자!


16. 행렬의 곱셈
이런 문제는 3중 for문이 나오는 등 복잡한 구조이기 때문에 주석을 잘 활용해서 큰 블록이 무슨 역할을 하는지 명확하게 하고 넘어가자!

17. 괄호 회전하기
map 사용하면 더 효율적으로 코드를 짤 수 있다!
그리고 중간에 여는거 없는데 들어오면 같다고 하자!


18. 위장
unordered_map은 insert 안하고 map[a]++; 해도 원소 추가됨


19. 튜플
비효율적으로 구현했다... 아래 점들을 간과한거 같다.
- 원소마다 s에서 나오는 횟수가 다르다.
- 문자열에서 숫자만 체크할거면 if문으로 조건 다 걸지말고 '0' < '9' 조건을 사용하자.
- 문자열 이어 붙이고 stoi를 이용하여 10의자리를 따로 계산하지 말자!